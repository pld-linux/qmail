diff -urN qmail-1.03.orig/Makefile qmail-1.03/Makefile
--- qmail-1.03.orig/Makefile	Sat Aug  5 01:10:07 2000
+++ qmail-1.03/Makefile	Sat Aug  5 01:15:48 2000
@@ -1534,12 +1534,12 @@
 qmail-smtpd: \
 load qmail-smtpd.o rcpthosts.o commands.o timeoutread.o \
 timeoutwrite.o ip.o ipme.o ipalloc.o control.o constmap.o received.o \
-date822fmt.o now.o qmail.o cdb.a fd.a wait.a datetime.a getln.a \
+date822fmt.o now.o qmail.o wildmat.o cdb.a fd.a wait.a datetime.a getln.a \
 open.a sig.a case.a env.a stralloc.a alloc.a substdio.a error.a str.a \
 fs.a auto_qmail.o socket.lib
 	./load qmail-smtpd rcpthosts.o commands.o timeoutread.o \
 	timeoutwrite.o ip.o ipme.o ipalloc.o control.o constmap.o \
-	received.o date822fmt.o now.o qmail.o cdb.a fd.a wait.a \
+	received.o date822fmt.o now.o qmail.o wildmat.o cdb.a fd.a wait.a \
 	datetime.a getln.a open.a sig.a case.a env.a stralloc.a \
 	alloc.a substdio.a error.a str.a fs.a auto_qmail.o  `cat \
 	socket.lib`
@@ -2139,3 +2139,7 @@
 wait_pid.o: \
 compile wait_pid.c error.h haswaitp.h
 	./compile wait_pid.c
+
+wildmat.o: \
+compile wildmat.c
+	./compile wildmat.c
diff -urN qmail-1.03.orig/README.wildmat qmail-1.03/README.wildmat
--- qmail-1.03.orig/README.wildmat	Thu Jan  1 01:00:00 1970
+++ qmail-1.03/README.wildmat	Sat Aug  5 01:13:57 2000
@@ -0,0 +1,50 @@
+wilmat patch version 0.2 for qmail 1.01
+Mark Delany <markd@mira.net.au>
+19971203
+
+Changes:
+--------
+0.1   Initial code
+0.2   Fixed buglet relating to systems that had no badmailfrom file
+      but do have a badmailpattern file
+
+While the 'badmailfrom' provides some ability to block spam it is
+fairly restricted as the match must be exact on either the full string
+or the domain. This means that it's very difficult to block the
+1234567@aol.com type addresses that some spammers are employing as you
+potentially require a large number of entries in 'badmailfrom'.
+
+This patch provides the ability to use simple patterns to reject mail
+from unwanted envelope sender addresses. Naturally all such methods
+are of limited use against spam as a determined spammer cannot be
+stopped on the current Internet, but it does help until the time comes
+that we can really stop spammers.
+
+The wildmat patch introduces a new control file called
+'badmailpatterns' and is used by qmail-smtpd in conjunction with
+'badmailfrom'. You should continue to use 'badmailfrom' when you can
+as this is much more CPU-efficient than 'badmailpatterns'.
+
+For those familiar with INN, the wildmat patch uses the wildmat()
+routine out of INN and evaluates in the same way. Namely that the
+envelope sender is pushed thru all patterns and the final match or
+non-match is used to determine whether to reject the mail. It's
+implemented this way so that 'not' patterns work.
+
+Here is a sample 'badmailpatterns' file:
+
+*@earthlink.net
+!fred@earthlink.net
+[0-9][0-9][0-9][0-9][0-9][0-9]@[0-9][0-9][0-9][0-9].com
+answerme@save*
+
+This file stops all mail from Earthlink except from
+fred@earthlink.net. It also stops all mail with addresses like:
+123456@1234.com and answerme@savetrees.com
+
+This patch does not update the documentation or qmail-showctl.
+
+Thanks to Rich Salz for providing wildmat.c by way of the INN
+distribution. wildmat.c is fast, small and completely self-contained.
+
+--
diff -urN qmail-1.03.orig/qmail-control.9 qmail-1.03/qmail-control.9
--- qmail-1.03.orig/qmail-control.9	Mon Jun 15 12:53:16 1998
+++ qmail-1.03/qmail-control.9	Sat Aug  5 01:34:01 2000
@@ -41,6 +41,7 @@
 control	default	used by
 
 .I badmailfrom	\fR(none)	\fRqmail-smtpd
+.I badmailpatterns	\fR(none)	\fRqmail-smtpd
 .I bouncefrom	\fRMAILER-DAEMON	\fRqmail-send
 .I bouncehost	\fIme	\fRqmail-send
 .I concurrencylocal	\fR10	\fRqmail-send
diff -urN qmail-1.03.orig/qmail-smtpd.8 qmail-1.03/qmail-smtpd.8
--- qmail-1.03.orig/qmail-smtpd.8	Sat Aug  5 01:10:07 2000
+++ qmail-1.03/qmail-smtpd.8	Sat Aug  5 01:33:04 2000
@@ -50,6 +50,28 @@
 meaning every address at
 .IR host .
 .TP 5
+.I badmailpatterns
+Unacceptable envelope sender addresses.
+.B qmail-smtpd
+will reject every recipient address for a message
+if the envelope sender address matches a set of patterns listed in
+.IR badmailpatterns .
+
+Here is a sample
+.I badmailpatterns
+file:
+
+.EX
+  *@earthlink.net
+  !fred@earthlink.net
+  [0-9][0-9][0-9][0-9][0-9][0-9]@[0-9][0-9][0-9][0-9].com
+  answerme@save*
+.EE
+
+This file stops all mail from Earthlink except from
+fred@earthlink.net. It also stops all mail with addresses like:
+123456@1234.com and answerme@savetrees.com
+.TP 5
 .I databytes
 Maximum number of bytes allowed in a message,
 or 0 for no limit.
diff -urN qmail-1.03.orig/qmail-smtpd.c qmail-1.03/qmail-smtpd.c
--- qmail-1.03.orig/qmail-smtpd.c	Sat Aug  5 01:10:07 2000
+++ qmail-1.03/qmail-smtpd.c	Sat Aug  5 01:25:49 2000
@@ -104,6 +104,8 @@
 int bmfok = 0;
 stralloc bmf = {0};
 struct constmap mapbmf;
+int bmpok = 0;        /* Badmail pattern */
+stralloc bmp = {0};
 
 void setup()
 {
@@ -133,7 +135,10 @@
   if (bmfok == -1) die_control();
   if (bmfok)
     if (!constmap_init(&mapbmf,bmf.s,bmf.len,0)) die_nomem();
- 
+
+  bmpok = control_readfile(&bmp,"control/badmailpatterns",0);
+  if (bmpok == -1) die_control();
+
   if (control_readint(&databytes,"control/databytes") == -1) die_control();
   x = env_get("DATABYTES");
   if (x) { scan_ulong(x,&u); databytes = u; }
@@ -217,13 +222,27 @@
 
 int bmfcheck()
 {
+  int i;
   int j;
-  if (!bmfok) return 0;
-  if (constmap(&mapbmf,addr.s,addr.len - 1)) return 1;
-  j = byte_rchr(addr.s,addr.len,'@');
-  if (j < addr.len)
-    if (constmap(&mapbmf,addr.s + j,addr.len - j - 1)) return 1;
-  return 0;
+  char subvalue, barf;
+
+  if (bmfok) {
+    if (constmap(&mapbmf,addr.s,addr.len - 1)) return 1;
+    j = byte_rchr(addr.s,addr.len,'@');
+    if (j < addr.len)
+      if (constmap(&mapbmf,addr.s + j,addr.len - j - 1)) return 1;
+  }
+ 
+  if (!bmpok) return 0;
+  i = 0; barf = 0;
+  for (j = 0;j < bmp.len;++j)
+   if (!bmp.s[j]) {
+    subvalue = bmp.s[i] != '!';
+    if (!subvalue) i++;
+    if ((barf != subvalue) && wildmat(addr.s, bmp.s + i)) barf = subvalue;
+    i = j + 1;
+  }
+  return barf;
 }
 
 int addrallowed()
diff -urN qmail-1.03.orig/wildmat.c qmail-1.03/wildmat.c
--- qmail-1.03.orig/wildmat.c	Thu Jan  1 01:00:00 1970
+++ qmail-1.03/wildmat.c	Sat Aug  5 01:13:57 2000
@@ -0,0 +1,172 @@
+/*  $Revision$
+**
+**  Do shell-style pattern matching for ?, \, [], and * characters.
+**  Might not be robust in face of malformed patterns; e.g., "foo[a-"
+**  could cause a segmentation violation.  It is 8bit clean.
+**
+**  Written by Rich $alz, mirror!rs, Wed Nov 26 19:03:17 EST 1986.
+**  Rich $alz is now <rsalz@osf.org>.
+**  April, 1991:  Replaced mutually-recursive calls with in-line code
+**  for the star character.
+**
+**  Special thanks to Lars Mathiesen <thorinn@diku.dk> for the ABORT code.
+**  This can greatly speed up failing wildcard patterns.  For example:
+**    pattern: -*-*-*-*-*-*-12-*-*-*-m-*-*-*
+**    text 1:  -adobe-courier-bold-o-normal--12-120-75-75-m-70-iso8859-1
+**    text 2:  -adobe-courier-bold-o-normal--12-120-75-75-X-70-iso8859-1
+**  Text 1 matches with 51 calls, while text 2 fails with 54 calls.  Without
+**  the ABORT code, it takes 22310 calls to fail.  Ugh.  The following
+**  explanation is from Lars:
+**  The precondition that must be fulfilled is that DoMatch will consume
+**  at least one character in text.  This is true if *p is neither '*' nor
+**  '\0'.)  The last return has ABORT instead of FALSE to avoid quadratic
+**  behaviour in cases like pattern "*a*b*c*d" with text "abcxxxxx".  With
+**  FALSE, each star-loop has to run to the end of the text; with ABORT
+**  only the last one does.
+**
+**  Once the control of one instance of DoMatch enters the star-loop, that
+**  instance will return either TRUE or ABORT, and any calling instance
+**  will therefore return immediately after (without calling recursively
+**  again).  In effect, only one star-loop is ever active.  It would be
+**  possible to modify the code to maintain this context explicitly,
+**  eliminating all recursive calls at the cost of some complication and
+**  loss of clarity (and the ABORT stuff seems to be unclear enough by
+**  itself).  I think it would be unwise to try to get this into a
+**  released version unless you have a good test data base to try it out
+**  on.
+*/
+
+#define TRUE                  1
+#define FALSE                 0
+#define ABORT                 -1
+
+
+    /* What character marks an inverted character class? */
+#define NEGATE_CLASS          '^'
+    /* Is "*" a common pattern? */
+#define OPTIMIZE_JUST_STAR
+    /* Do tar(1) matching rules, which ignore a trailing slash? */
+#undef MATCH_TAR_PATTERN
+
+
+/*
+**  Match text and p, return TRUE, FALSE, or ABORT.
+*/
+static int
+DoMatch(text, p)
+    register char     *text;
+    register char     *p;
+{
+    register int      last;
+    register int      matched;
+    register int      reverse;
+
+    for ( ; *p; text++, p++) {
+      if (*text == '\0' && *p != '*')
+          return ABORT;
+      switch (*p) {
+      case '\\':
+          /* Literal match with following character. */
+          p++;
+          /* FALLTHROUGH */
+      default:
+          if (*text != *p)
+              return FALSE;
+          continue;
+      case '?':
+          /* Match anything. */
+          continue;
+      case '*':
+          while (*++p == '*')
+              /* Consecutive stars act just like one. */
+              continue;
+          if (*p == '\0')
+              /* Trailing star matches everything. */
+              return TRUE;
+          while (*text)
+              if ((matched = DoMatch(text++, p)) != FALSE)
+                  return matched;
+          return ABORT;
+      case '[':
+          reverse = p[1] == NEGATE_CLASS ? TRUE : FALSE;
+          if (reverse)
+              /* Inverted character class. */
+              p++;
+          matched = FALSE;
+          if (p[1] == ']' || p[1] == '-')
+              if (*++p == *text)
+                  matched = TRUE;
+          for (last = *p; *++p && *p != ']'; last = *p)
+              /* This next line requires a good C compiler. */
+              if (*p == '-' && p[1] != ']'
+                  ? *text <= *++p && *text >= last : *text == *p)
+                  matched = TRUE;
+          if (matched == reverse)
+              return FALSE;
+          continue;
+      }
+    }
+
+#ifdef        MATCH_TAR_PATTERN
+    if (*text == '/')
+      return TRUE;
+#endif        /* MATCH_TAR_ATTERN */
+    return *text == '\0';
+}
+
+
+/*
+**  User-level routine.  Returns TRUE or FALSE.
+*/
+int
+wildmat(text, p)
+    char      *text;
+    char      *p;
+{
+#ifdef        OPTIMIZE_JUST_STAR
+    if (p[0] == '*' && p[1] == '\0')
+      return TRUE;
+#endif        /* OPTIMIZE_JUST_STAR */
+    return DoMatch(text, p) == TRUE;
+}
+
+
+
+#if   defined(TEST)
+#include <stdio.h>
+
+/* Yes, we use gets not fgets.  Sue me. */
+extern char   *gets();
+
+
+int
+main()
+{
+    char       p[80];
+    char       text[80];
+
+    printf("Wildmat tester.  Enter pattern, then strings to test.\n");
+    printf("A blank line gets prompts for a new pattern; a blank pattern\n");
+    printf("exits the program.\n");
+
+    for ( ; ; ) {
+      printf("\nEnter pattern:  ");
+      (void)fflush(stdout);
+      if (gets(p) == NULL || p[0] == '\0')
+          break;
+      for ( ; ; ) {
+          printf("Enter text:  ");
+          (void)fflush(stdout);
+          if (gets(text) == NULL)
+              exit(0);
+          if (text[0] == '\0')
+              /* Blank line; go back and get a new pattern. */
+              break;
+          printf("      %s\n", wildmat(text, p) ? "YES" : "NO");
+      }
+    }
+
+    exit(0);
+    /* NOTREACHED */
+}
+#endif        /* defined(TEST) */
